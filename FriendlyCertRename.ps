#
# Get all certs with a blank Friendly Name and populate it with a concatenation of CN and Cert Template 
#
Get-ChildItem Cert:\LocalMachine\my |where FriendlyName -eq "" | Transform-Certificate | ForEach-Object {
	if ($_.PrivateKey.CspKeyContainerInfo.UniqueKeyContainerName) {
		if ((Check-Write-Access($_)) -eq 0) {
			if ($_.Template) {
				$_.FriendlyName=-join(($_.Subject -replace "(CN=)(.*?)",'$2'),"-",($_.Template -replace "(?ms)(Template=)(.*)\((.*$)",'$2'))
			} 
			else {
				Write-Host "No Template name for " + $_.Subject + " Probably not an MS PKI Cert - skipped"
			}
		} 
		else {
			Write-Host "Unable to write to certificiate object " + $_.Subject + " Check you are runnin gthis with Elevated permissions"
		}
	}
}
exit
#
# Transform_Certificate (credit Vadims Podans of PKI Solutions Inc)
# Takes certificate data from Get-ChildItem and expands the extended properties to obtain the Template that was used to create the certificate request (if it exists - MS PKI certs only)
# Returns the object with properties populated - for full list of properties see X509Certificate2.Properties file
#
function Transform-Certificate {
 [CmdletBinding()]
 param(
	[Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
	[Security.Cryptography.X509Certificates.X509Certificate2]$cert
 )
	process {
		$temp = $cert.Extensions | ?{$_.Oid.Value -eq "1.3.6.1.4.1.311.20.2"}
 		if (!$temp) {
			$temp = $cert.Extensions | ?{$_.Oid.Value -eq "1.3.6.1.4.1.311.21.7"}
 		}
		if ($temp) {
        		$cert | Add-Member -Name Template -MemberType NoteProperty -Value $temp.Format(1) -PassThru
		}
		else {
			return 1
		}
 	}
}

function Check-Write-Access {
 [CmdletBinding()]
 param(
	[Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)] 
	[Security.Cryptography.X509Certificates.X509Certificate2]$cert
 )
	$rsaFile = $cert.PrivateKey.CspKeyContainerInfo.UniqueKeyContainerName
	$keyPath = "C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys\"
	$fullPath=$keyPath+$rsaFile
	try {
		$filetest =  [IO.FILE]::OpenWrite($fullpath)
		$filetest.close()
		Return 0
	}
	catch { Return 1 }
}
